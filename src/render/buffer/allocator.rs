use std::{collections::hash_map::Iter};

use ahash::HashMap;
use bytemuck::Pod;
use ultraviolet::IVec3;
use vulkano::{buffer::{BufferContents, BufferUsage, Subbuffer}, memory::allocator::StandardMemoryAllocator, command_buffer::DrawIndirectCommand};

use super::swap_buffer::SwapBufferSlice;

pub struct HeapBuffer<T> 
where [T]: BufferContents,
{
    buffer: SwapBufferSlice<T>,
    chunk_allocator: ChunkBufferAllocator,
    pub allocations: HashMap<IVec3, ChunkBufferAllocation>,
    pub uploaded: Vec<(IVec3, ChunkBufferAllocation)>,
    pub indirect_buffer: Option<Subbuffer<[DrawIndirectCommand]>>,
    pub vertex_count_multiplier: u32,
    pub highest: usize,
}

impl<U> HeapBuffer<U> 
where 
    U: Copy + Clone + Send + Sync + Pod,
    [U]: BufferContents,
{
    pub fn new(allocator: &StandardMemoryAllocator, usage: BufferUsage, size: usize, vertex_count_multiplier: u32) -> Self {
        HeapBuffer {
            buffer: SwapBufferSlice::new(size, usage, allocator),
            chunk_allocator: ChunkBufferAllocator::new(),
            allocations: HashMap::default(),
            uploaded: Vec::new(),
            indirect_buffer: None,
            vertex_count_multiplier,
            highest: 0
        }
    }

    pub fn update(&mut self) -> bool {
        let swapped = self.buffer.update();
        if swapped {
            self.uploaded = self.allocations.iter()
                .map(|(v, alloc)| { (*v, *alloc) }).collect();
        }
        swapped
    }

    pub fn insert(
        &mut self, 
        section_pos: IVec3, 
        data: &[U],
    ) -> ChunkBufferAllocation {
        let size = data.len() as u32;
        let allocation = self.chunk_allocator.allocate(size);
        if allocation.back as usize > self.highest {
            self.highest = allocation.back as usize;
        }

        self.allocations.insert(section_pos, allocation);
        self.buffer.write(allocation.front.try_into().unwrap(), data);
        allocation
    }

    pub fn remove(&mut self, section_pos: IVec3) {
        if let Some(allocation) = self.allocations.remove(&section_pos) {
            self.chunk_allocator.deallocate(&allocation);
            // No need to push to queue, corresponding memory will not be read
        } else {
            println!("WARNING: Tried to remove chunk that was not allocated. Section: {:?}", section_pos);
        }
    }

    pub fn reinsert(
        &mut self, 
        section_pos: IVec3, 
        data: &[U],
    ) {
        self.remove(section_pos);
        self.insert(section_pos, data);
    }

    pub fn get_buffer(&self) -> Subbuffer<[U]> {
        self.buffer.buffer.current_buffer()
    }

    pub fn get_ind_commands(&self) -> Vec<DrawIndirectCommand> {
        self.allocations.values().map(|alloc| {
            alloc.to_draw_command(self.vertex_count_multiplier)
        }).collect()
    }
}

/// Describes an allocation in the chunk vertex buffer. Has no real spot in the memory backing it.
#[derive(Copy, Clone, Debug)]
pub struct ChunkBufferAllocation {
    pub front: u32,
    pub back: u32,
}

impl ChunkBufferAllocation {
    pub fn to_draw_command(&self, multiplier: u32) -> DrawIndirectCommand {
        DrawIndirectCommand {
            vertex_count: (self.back - self.front) * multiplier,
            instance_count: 1,
            first_vertex: self.front * multiplier,
            first_instance: 0,
        }
    }

    fn new(front: u32, back: u32) -> Self {
        Self { front, back }
    }

    fn new_size(front: u32, size: u32) -> Self {
        Self::new(front, front + size)
    }
}

struct ChunkBufferAllocator {
    /// Represents all free sections
    dual_map: DualHashMap<u32>,
    top: u32,
}

impl ChunkBufferAllocator {
    fn new() -> Self {
        Self {
            dual_map: DualHashMap::new(),
            top: 0,
        }
    }

    fn allocate(&mut self, size: u32) -> ChunkBufferAllocation {
        if let Some((front, back, free_size)) = Self::find_free(&self.dual_map, size) {
            self.dual_map.remove_front(&front);
            if free_size != size { self.dual_map.insert(front + size, back); }
            ChunkBufferAllocation::new_size(front, size)
        } else {
            let old_top = self.top;
            self.top += size;
            ChunkBufferAllocation::new_size(old_top, size)
        }
    }

    /// Deallocates a section and marks it as free.<br>
    /// <b>DOES NOT CHECK IF THIS ALLOCATION IS VALID</b>. *Use an allocation generated by* `.allocate()`
    fn deallocate(&mut self, alloc: &ChunkBufferAllocation) {
        let mut joined_alloc = alloc.clone();

        if let Some(back) = self.dual_map.remove_front(&alloc.back) {
            joined_alloc.back = back.to_owned();
        }

        if let Some(front) = self.dual_map.remove_back(&alloc.front) {
            joined_alloc.front = front.to_owned();
        }

        self.dual_map.insert(joined_alloc.front, joined_alloc.back);
    }

    fn find_free(map: &DualHashMap<u32>, needed_size: u32) -> Option<(u32, u32, u32)> {
        for (front, back) in map.iter() {
            let free_size = back - front;
            if needed_size <= free_size {
                return Some((front.to_owned(), back.to_owned(), free_size))
            }
        }
        None
    }
}

struct DualHashMap<T> {
    front_back: HashMap<T, T>,
    back_front: HashMap<T, T>,
}

impl<T> DualHashMap<T> 
where
    T: std::hash::Hash + std::cmp::Eq + Clone
{
    fn new() -> Self {
        Self {
            front_back: HashMap::default(),
            back_front: HashMap::default(),
        }
    }

    fn insert(&mut self, front: T, back: T) {
        self.front_back.insert(front.clone(), back.clone());
        self.back_front.insert(back, front);
    }

    fn _get_back(&self, front: &T) -> Option<&T> {
        self.front_back.get(front)
    }

    fn _get_front(&self, back: &T) -> Option<&T> {
        self.back_front.get(back)
    }

    /// Removes the pair with the specified front, returning the back if it existed.
    fn remove_front(&mut self, front: &T) -> Option<T> {
        match self.front_back.remove(front) {
            Some(back) => {
                self.back_front.remove(&back);
                Some(back)
            },
            None => None
        }        
    }

    /// Removes the pair with the specified back, returning the front if it existed.
    fn remove_back(&mut self, back: &T) -> Option<T> {
        match self.back_front.remove(back) {
            Some(front) => {
                self.front_back.remove(&front);
                Some(front)
            },
            None => None
        }   
    }

    fn iter(&self) -> Iter<'_, T, T> {
        self.front_back.iter()
    }
}